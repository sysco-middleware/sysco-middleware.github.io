I"∑)<h1 id="introduction">Introduction</h1>
<p>In this post, we will take a look at 3 libraries/tools for testing end points of web-services.</p>
<h2 id="content">Content:</h2>
<ol>
  <li>Application under test</li>
  <li>RestAssured<br />
2.1. Definition<br />
2.2. Main features<br />
2.3. Use case (diagram)</li>
  <li>WireMock<br />
3.1. Definition<br />
3.2. Main features<br />
3.3. Use case (diagram)</li>
  <li>Testcontainers<br />
4.1. Definition<br />
4.2. Main features<br />
4.3. Use case (diagram)<br />
4.4. Additional (Awatility)</li>
  <li>Summary</li>
</ol>

<h2 id="1-application-under-test">1. Application under test</h2>

<p><a href="https://github.com/NikitaZhevnitskiy/ern-card-game">Application repository</a><br />
Application is a card-game RESTapi, build with: Spring-boot, kotlin, netflix tech stack (Zuul, Ribbon, Eureka) micro-services architecture. 
Project is exam delivery for subject PG6100-1 Java enterprise-2 at <a href="https://www.westerdals.no/">Westerdals</a>.</p>

<h3 id="2-restassured">2. <a href="https://github.com/rest-assured/rest-assured">RestAssured</a></h3>

<h3 id="21-definition">2.1. Definition</h3>

<p>Library for testing and validation REST APIs.</p>

<h3 id="22-main-features">2.2. Main features</h3>

<ul>
  <li>Maven / Gradle integration</li>
  <li>Json- Xml-, path for simple parse</li>
  <li>JVM languages support (Java, Kotlin, etc‚Ä¶)</li>
</ul>

<p>In current project RestAssured uses in each module, to perform http calls and validate responses.</p>

<h3 id="23-use-case">2.3. Use case</h3>

<p>Create new player.</p>

<p><img src="/images/2018-01-19-web-service-testing/case1.png" alt="Use case 1" /></p>

<p>Setup RestAssured configuration.</p>

<p><code class="highlighter-rouge">no.ern.game.player.controller.TestBase.kt</code></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>...

@Before
@After
fun clean() {
    // RestAssured configs shared by all the tests
    RestAssured.baseURI = &lt;HOST&gt;
    RestAssured.port = &lt;PORT&gt;
    RestAssured.basePath = "/players"
}
...
</code></pre></div></div>

<p>Test example.</p>

<p><code class="highlighter-rouge">no.ern.game.player.controller.PlayerControllerTest.kt</code></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>...
@Test
fun createAndGetPlayer_Valid() {
    val playerDto1 = getValidPlayerDtos()[0]
    
    val savedId = given().contentType(ContentType.JSON)
        .body(playerDto1)
        .post()
        .then()
        .statusCode(201)
        .extract().`as`(Long::class.java)
            
    ...           
}
</code></pre></div></div>

<h2 id="3-wiremock">3. <a href="http://wiremock.org">WireMock</a></h2>

<p>WireMock is an HTTP mock server. Provide opportunity to test services in isolation.</p>

<h3 id="31-definition">3.1. Definition</h3>

<p>This library gives opportunity to trigger outbound request, mock target service and stub response.
Wiremock provides range of opportunities to test microservices in isolation from each other.</p>

<h3 id="32-main-features">3.2. Main features</h3>

<ul>
  <li>Mocking, stubbing, verifying, proxying</li>
  <li>Support SSL (HTTPS)</li>
</ul>

<h3 id="33-use-case">3.3. Use case</h3>

<p><img src="/images/2018-01-19-web-service-testing/case2.png" alt="Use case 2 " /></p>

<p>Setup wiremock testbase.</p>

<p><code class="highlighter-rouge">no.ern.game.player.controller.WiremockTestBase.kt</code></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>companion object {
    lateinit var wiremockServerItem: WireMockServer
    
    @BeforeClass
    @JvmStatic
    fun initClass() {
        ...
        wiremockServerItem = WireMockServer(WireMockConfiguration.wireMockConfig().port(&lt;PORT&gt;).notifier(ConsoleNotifier(true)))
        wiremockServerItem.start()
    
    }
    
    @AfterClass
    @JvmStatic
    fun tearDown() {
        wiremockServerItem.stop()
    }
  
}        
</code></pre></div></div>

<p>Kotlin did not support <code class="highlighter-rouge">static</code> when application was developed (maybe it has been changed already), we used companion object instead. <br />
Test example.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@Test
fun testAddItemToPlayer_Valid() {
    val playerDto1 = getValidPlayerDto()
    val savedId = RestAssured.given().contentType(ContentType.JSON)
        .body(playerDto1)
        .post()
        .then()
        .statusCode(201)
        .extract().`as`(Long::class.java)
  
    // stub rule 
    wiremockServerItem.stubFor(
        WireMock.get(urlMatching(".*/items/1"))
            .willReturn(
                WireMock.aResponse()
                    .withStatus(200)))
  
    val item = ItemDto(id = "1")
    
    val response = RestAssured.given()
        .contentType(ContentType.JSON)
        .body(item)
        .post("/$savedId/items")
        .statusCode(200)
</code></pre></div></div>

<h2 id="4-testcontainers">4. <a href="https://www.testcontainers.org/">Testcontainers</a></h2>

<h3 id="41-definition">4.1. Definition</h3>

<p>In two words tests in docker containers. Testcontainers offers opportunities to test -integration, -application layers, and UI tests(i.e. with selenium).</p>

<h3 id="42-main-features">4.2. Main features</h3>
<ul>
  <li>Simple access layer integration test: MySQL, PostgreSQL &amp; Oracle.</li>
  <li>Tests against docker-compose environment</li>
  <li>Containerized web browsers, compatible with Selenium</li>
  <li>Opportunity to record video for UI tests</li>
  <li>Generic containers (use own images)</li>
  <li>Accessing containers from tests
    <h3 id="43-use-case">4.3. Use case</h3>
  </li>
</ul>

<p>We use this library for end-to-end tests, validation and check most important components in application. Application deployed in docker-compose environment, using local docker-compose and generic containers.</p>

<ul>
  <li>Validate infrastructure (gateway, service discovery and access)</li>
  <li>Validate microservices security access</li>
  <li>Validate main system features</li>
  <li>Validate game logic processes</li>
</ul>

<p><img src="/images/2018-01-19-web-service-testing/case3.png" alt="Application" /></p>

<p>Setup docker-compose environment.</p>

<p><code class="highlighter-rouge">no.ern.game.e2etests.AuthFeatureIT</code></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>...
companion object {

    class KDockerComposeContainer(path: File) : DockerComposeContainer&lt;KDockerComposeContainer&gt;(path)
    
    
    @ClassRule
    @JvmField
    val env = KDockerComposeContainer(File("../docker-compose.yml"))
        .withLocalCompose(true)
    
    @BeforeClass
    @JvmStatic
    fun initialize() {
        RestAssured.baseURI = "http://localhost"
        RestAssured.port = 10000
        RestAssured.enableLoggingOfRequestAndResponseIfValidationFails()
    
        await().atMost(240, TimeUnit.SECONDS)
            .ignoreExceptions()
            .until({
                given().get("http://localhost:10000/api/v1/user").then().statusCode(401)
    
                true
            })
    }
}
...

</code></pre></div></div>

<p>Test example.</p>

<p><code class="highlighter-rouge">no.ern.game.e2etests.AuthFeatureIT</code></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>...
@Test
fun testLogin() {
    val id = createUniqueId()
    val pwd = "bar"
    
    val cookies = registerUser(id, pwd)
    
    given().get("/api/v1/user")
        .then()
        .statusCode(401)
    
    //note the difference in cookie name
    given().cookie("SESSION", cookies.session)
        .get("/api/v1/user")
        .then()
        .statusCode(200)
        .body("name", equalTo(id))
        .body("roles", contains("ROLE_USER"))
    
    
    given().auth().basic(id, pwd)
        .get("/api/v1/user")
        .then()
        .statusCode(200)
        .cookie("SESSION")
        .body("name", equalTo(id))
        .body("roles", contains("ROLE_USER"))
}
...
</code></pre></div></div>

<h3 id="44-additional-awatility">4.4. Additional <a href="https://github.com/awaitility/awaitility">Awatility</a></h3>

<p>Java library for sync async operations. It is very convenient tool to write automated test in async environment.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">await</span><span class="p">().</span><span class="nf">atMost</span><span class="p">(</span><span class="m">240</span><span class="p">,</span> <span class="nc">TimeUnit</span><span class="p">.</span><span class="nc">SECONDS</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">ignoreExceptions</span><span class="p">()</span>
    <span class="p">.</span><span class="nf">until</span><span class="p">({</span>
        <span class="nf">given</span><span class="p">().</span><span class="k">get</span><span class="p">(</span><span class="s">"http://localhost:10000/api/v1/user"</span><span class="p">).</span><span class="nf">then</span><span class="p">().</span><span class="nf">statusCode</span><span class="p">(</span><span class="m">401</span><span class="p">)</span>

        <span class="k">true</span>
<span class="p">})</span>
</code></pre></div></div>

<p>We use it at:</p>

<ul>
  <li>Waiting until all nodes in application will be deployed, registered in service discovery and be accessible.
We wait max 4 minutes, while waiting call gateway with RestAssured GET /user in a loop until success, 
ignore any exceptions. Success symbolize that last microservice in application is UP and system 
run tests, if timeout riches than fail test suite</li>
  <li>Async operations: message broker processing, node communications and etc‚Ä¶</li>
</ul>

<h2 id="5-summary">5. Summary</h2>
<p>Well, that was short overview of testing tools for web-services and application with microservice architecture. 
RestAssured and WireMock libraries are well known among java developers. Testcontainers is something ‚Äúnew‚Äù (5 years history) to automate settings of containers environment. 
TestContainers run containers for automated tests and destroy them right after. Testcontainers library decreases integrated tests complexity. 
And ‚ÄòYES‚Äô, you do not need install anymore Oracle database to run tests.</p>

<h2 id="links">Links</h2>
<ul>
  <li><a href="https://vimeo.com/222501136">TestContainers - Richard North</a></li>
  <li><a href="https://www.slideshare.net/rich.north/testcontainers-geekout-ee-2017-presentation">Testcontainers - Geekout EE 2017 presentation</a></li>
</ul>

:ET